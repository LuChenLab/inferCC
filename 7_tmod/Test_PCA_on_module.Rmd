---
title: "Test_PCA_on_module"
author: "Zhang Yiming"
date: "6/18/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tmod)
library(openxlsx)
library(stringr)
library(wesanderson)
library(dplyr)
library(reshape2)
```

## Test on APII ADC

```{r cars}
ap2 <- readRDS("/mnt/raid62/Lung_cancer_10x/02_figures_each_cell/Alveolar_II_ADC/Alveolar_II.rds")
```

```{r fig.height=6, fig.width=6}
make_pca_plots <- function(pcobj, object, n.pcs=50, ncol=4, dot.size=0.1) {
    
    n.pcs = min(n.pcs, ncol(pcobj$rotation))
    
    plist = list()
    for(i in 1:(n.pcs - 1)) {
        key1 = paste("PC", i, sep = "")
        key2 = paste("PC", i + 1, sep = "")
        
        temp = pcobj$x[, c(key1, key2), drop = F]
        temp = as.data.frame(temp)
        
        temp$Stage = as.character(object@meta.data[rownames(temp), "Stage"])
        # print(head(temp))
        
        p <- eval(
            parse(
                text=paste0("ggplot(data = temp, aes(x=", key1, ", y = ", key2, ", color = Stage))")
            )
        )
    
        plist[[length(plist) + 1]] = p + geom_point(size=dot.size) + guides(colour = guide_legend(override.aes = list(size=5)))
    }
    
    p <- cowplot::plot_grid(plotlist = plist, ncol = ncol)
    return(p)
}
```

#### 所有基因，进行PCA降维，观察哪一个PC能够将细胞分开
```{r}
ap2_pca <- prcomp(t(ap2@scale.data), center = FALSE, scale. = FALSE)
```
```{r fig.height=16, fig.width=20}
p <- make_pca_plots(ap2_pca, ap2, n.pcs = 16)

print(p)
```


#### using spearman to calculate the r of each pc

```{r}

make_cor_plots <- function(pcobj, object, n.pcs = 100) {
    
    stage_to_int = c(
        "I"=1,
        "II"=2,
        "III"=3,
        "IV"=4
    )
    
    n.pcs = min(n.pcs, ncol(pcobj$rotation))
    
    stages = object@meta.data[rownames(pcobj$x), "Stage"]
    stages = sapply(stages, function(x){return(stage_to_int[[x]])})
    
    res = matrix(NA, ncol = 2, nrow = n.pcs)
    for (i in 1:n.pcs) {
        res[i, 1] = i
        res[i, 2] = cor(stages, pcobj$x[, i], method="spearman")
    }
    
    colnames(res) <- c("PC", "r")
    res = as.data.frame(res)

    res$PC = factor(res[, 1], levels = sort(unique(res[, 1])))
    
    # print(head(res))
    
    ggplot(data = as.data.frame(res), aes(x = PC, y = r)) + geom_point() + theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 1))
}
```

```{r fig.height=6, fig.width=18}
make_cor_plots(ap2_pca, ap2)
```
不同的PC与不同时期之间的相关性并不是很高，较高的仅为PC2, PC5, PC7和PC21

#### 仅处理特异表达的基因，观察哪一个PC能够将细胞分开
```{R}
ap2_clt = read.xlsx("/mnt/raid62/Lung_cancer_10x/02_figures_each_cell/Alveolar_II_ADC/annotation_results_by_stage.xlsx", rowNames = T)
```

```{r}
ap2_clt_pca <- prcomp(t(ap2@scale.data[unique(ap2_clt$gene), , drop = FALSE]), center = FALSE, scale. = FALSE)
```
```{r fig.height=16, fig.width=20}
p <- make_pca_plots(ap2_clt_pca, ap2, n.pcs = 16)

print(p)
```

### 测试所有基因做tmod的效果

```{r}
msig <- tmodImportMSigDB("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/msigdb_v6.2.xml")
sel <- msig$MODULES$Category %in% c("H","C5","C2")
```


```{r}
make_dotplot_of_different_pc <- function(pcobj, cluster, output_xlsx, msig, sel, n.pcs = 30) {

    resU = NULL
    resC = NULL
    resZ = NULL
    for(j in 1:n.pcs) {
        
        
        genes_order_by_pc <- row.names(pcobj$rotation[order(abs(pcobj$rotation[, j]), decreasing = T), ])
        
        for(i in unique(cluster$ident)) {
            temp_genes = genes_order_by_pc[genes_order_by_pc %in% cluster[cluster$ident == i, "gene"]]
            # print(head(temp_genes))
            
            temp = tmodUtest(temp_genes, mset = msig[sel], qval = Inf)    
            
            if(nrow(temp) > 0) {
                temp$ident = i
                temp$pc = j
                resU = rbind(resU, temp)
            }
            
            
            temp = tmodCERNOtest(temp_genes, mset = msig[sel], qval = Inf)    
        
            if(nrow(temp) > 0) {
                temp$ident = i
                temp$pc = j
                resC = rbind(resC, temp)
            }
            
            temp = tmodZtest(temp_genes, mset = msig[sel], qval = Inf)    
        
            if(nrow(temp) > 0) {
                temp$ident = i
                temp$pc = j
                resZ = rbind(resZ, temp)
            }
        }
    }
    
    
    wb = createWorkbook()
    addWorksheet(wb, "Utest")
    writeData(wb, 1, resU)
    
    addWorksheet(wb, "CERNO")
    writeData(wb, 2, resC)
    
    addWorksheet(wb, "Ztest")
    writeData(wb, 3, resZ)
    
    saveWorkbook(wb, file = output_xlsx, overwrite = T)
    
    return(list(
        "Utest"=resU,
        "CERNOtest"=resC,
        "Ztest"=resZ
    ))
}


res_ap2 = make_dotplot_of_different_pc(
    pcobj = ap2_pca,
    cluster = ap2_clt,
    msig=msig,
    sel=sel,
    output_xlsx = "/mnt/raid62/Lung_cancer_10x/05_tmod_stage/APII_pc3_sorting_tmod.xlsx"
)
```


#### make dot plot compare 
```{R}
make_dotplot_of_different_pc_tmod <- function(res, auc=0.5, p.val = 0.05, top=10) {
    res = as.data.frame(res)
    res = res[res$AUC > auc & res$P.Value < p.val, ]
    
    temp = as.data.frame(res %>%  dplyr::group_by(ident, pc) %>% dplyr::top_n(-top, wt=P.Value))
    
    temp$pc = factor(temp$pc, levels = sort(unique(temp$pc)))
    
    ggplot(
        data = temp, aes(x=pc, y = Title, color=P.Value, size=N1)
    ) + 
        geom_point() +
        facet_wrap(ident~., scales="free", ncol = 2) +
        theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 1)) +
        scale_color_gradientn(colors=rev(wes_palette("Zissou1", 100, type = "continuous")))
}
```

```{r fig.height=40, fig.width=30}
make_dotplot_of_different_pc_tmod(res=res_ap2[["Utest"]], top=8)
```


### 统计下，每个PC上合格的通路数量

分别以不同pc排序，每个时期上合格的tmod通路数量

##### Utest
```{R fig.height=6, fig.width=12}
temp <- res_ap2[["Utest"]] %>% filter(AUC > 0.5 & adj.P.Val < 0.05) %>% group_by(pc, ident) %>% add_tally() %>% select(pc, ident, n) %>% unique()

temp$pc = factor(temp$pc, levels = sort(unique(temp$pc)))
ggplot(data=temp, aes(x = pc, y = ident, size = n))  + geom_point() + labs(title = "Utest")
```

##### CERNOtest
```{R fig.height=6, fig.width=12}
temp <- res_ap2[["CERNOtest"]] %>% filter(AUC > 0.5 & adj.P.Val < 0.05) %>% group_by(pc, ident) %>% add_tally() %>% select(pc, ident, n) %>% unique()

temp$pc = factor(temp$pc, levels = sort(unique(temp$pc)))
ggplot(data=temp, aes(x = pc, y = ident, size = n))  + geom_point() + labs(title = "CERNO")
```


##### Ztest
```{R fig.height=6, fig.width=12}
temp <- res_ap2[["Ztest"]] %>% filter(AUC > 0.5 & adj.P.Val < 0.05) %>% group_by(pc, ident) %>% add_tally() %>% select(pc, ident, n) %>% unique()

temp$pc = factor(temp$pc, levels = sort(unique(temp$pc)))
ggplot(data=temp, aes(x = pc, y = ident, size = n))  + geom_point() + labs(title = "Ztest")
```


---

PC5可能潜在一定时序分期作用，测试按照PC5注释出的tmod与mfuzz的结果取overlap，做雷达图观察效果

###### 提取PC5中所有module的基因
```{r}
modules_pc5 <- NULL
temp = res_ap2[["Utest"]]
temp = temp[temp$pc == 5 & temp$AUC > 0.5 & temp$adj.P.Val < 0.05,]
for(i in temp$ID) {
    print(i)
    modules_pc5 <- rbind(
        modules_pc5, 
        data.frame(
            stage=temp[i, "ident"],
            gene=intersect(
                msig$MODULES2GENES[[i]], 
                ap2_clt[ap2_clt$ident == temp[i, "ident"], "gene"]
            )
        )
    )
}


```

---
## 第二轮，对已有的module做PCA，看能不能从PCA上区分不同时期


```{r pressure, echo=FALSE}
format_module <- function(modules, mfuzz=TRUE) {
    
    short_name = c(
        "Alveolar_II"="APII",
        "B_cells"="B",
        "Basal"="Basal",
        "CD4"="CD4",
        "Ciliated"="Cili",
        "Club"="Club",
        "Dendritic"="Dend",
        "Endothelial"="Endp",
        "Erythroid_precursor"="Eryt",
        "Fibroblasts"="Fibr",
        "Goblet"="Goblet",
        "Granulocyte"="Granu",
        "Mast"="Mast",
        "Monocytes"="Mono",
        "NK"="NK",
        "T_cells"="T",
        "Treg"="Treg",
        "Neuroendocrine"="Neuro",
        "Exhaust_T"="Exha"
    )
    
    
    res  = NULL
    
    for(i in 1:nrow(modules)) {
        temp_cell = short_name[[str_replace(modules[i, 1], "_(SCC|ADC)", "")]]
        
        temp = data.frame(
            gene = str_split(modules[i, "Genes"], "\\|")[[1]], 
            module_id = paste(temp_cell, modules[i, "Stage"], sep = "."),
            Cells = modules[i, "Cell_name"]
        )
        
        if(mfuzz) {
            temp$module_id = paste(temp$module_id, modules[i, "Mfuzz_ID"], sep = ".")
        }
        
        res = rbind(res, temp)
    }
    
    return(res)
}
```


```{r}
modules = read.xlsx("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/tmod_mfuzz_overlap_AUC_0.5_merged.xlsx", sheet = 2)
modules = modules[modules$Cell_name == "Alveolar_II_ADC", ]
```


#### 对每个module的基因进行PCA，拆分看其能够有效拆分不同Stage

不按照mfuzz id进行细分，只分不同Stage
```{r fig.height=16, fig.width=20}
modules1 = format_module(modules, mfuzz=FALSE)

for(i in unique(modules1$module_id)) {
    temp_pca <- prcomp(t(ap2@scale.data[unique(modules1$gene[modules1$module_id == i]), , drop = FALSE]), center = FALSE, scale. = FALSE)

    p <- make_pca_plots(temp_pca, ap2, n.pcs = 16)
    p = p + labs(title = i)
    
    print(p)
}


```


按照mfuzz id进行细分
```{r}
modules2 = format_module(modules, mfuzz=TRUE)
```


```{r fig.height=16, fig.width=20}
for(i in unique(modules2$module_id[modules2$Cells == "Alveolar_II_ADC"])) {
    temp_pca <- prcomp(t(ap2@scale.data[unique(modules2$gene[modules2$module_id == i]), , drop = FALSE]), center = FALSE, scale. = FALSE)
    
    
    tryCatch(
        {
            p <- make_pca_plots(temp_pca, ap2, n.pcs = 16)
            p = p + labs(title = i)
            
            print(p)
        },
        error=function(cond) {},
        warning=function(cond) {},
        finally={}
    )    

}
```

做几个mfuzz结果的热图对比
```{R}
mfuzz <- read.xlsx("/mnt/raid62/Lung_cancer_10x/02_figures_each_cell/Alveolar_II_ADC/mfuzz_gene_module/results.xlsx")
```

```{r}
for(i in sort(unique(mfuzz$gene_module_id))) {
    p <- DoHeatmap(ap2, genes.use = unique(mfuzz$gene[mfuzz$gene_module_id == i]), group.by = "Stage", do.plo = F, slim.col.label = T)
    print(p)
}
```


```{r fig.height=16, fig.width=20}
for(i in sort(unique(mfuzz$gene_module_id))) {
    temp_pca <- prcomp(t(ap2@scale.data[unique(mfuzz$gene[mfuzz$gene_module_id == i]), , drop = FALSE]), center = FALSE, scale. = FALSE)

    p <- make_pca_plots(temp_pca, ap2, n.pcs = 16)
    p = p + labs(title = i)
    print(i)
    print(p)
}
```

### 用所有mfuzz的基因
```{r fig.height=16, fig.width=16}
temp_pca <- prcomp(t(ap2@scale.data[unique(mfuzz$gene), , drop = FALSE]), center = FALSE, scale. = FALSE)

p <- make_pca_plots(temp_pca, ap2, n.pcs = 16)
print(p)
```

通过spearman相关性，看是哪个PC与时期最相关
```{r fig.height=6, fig.width=16}
make_cor_plots(temp_pca, ap2)
```


不同时期做violin plot
```{r fig.height=16, fig.width=8}
make_violin_plot <- function(pcobj, object, n.pcs = 1) {
    temp = pcobj$x[, 1:n.pcs, drop = F]
    temp = melt(temp)
    
    temp$Stage = object@meta.data[temp$Var1, "Stage"]
    
    ggplot(data = temp, aes(x = Stage, y = value, fill = Stage)) + 
        geom_violin() + 
        facet_grid(Var2~., scales = "free_y") +
        stat_summary(fun.y=median, geom="point", size=2)
}


make_violin_plot(temp_pca, ap2, 5)
```

看一下是不是不同基因在不同PC上的权重大小？
```{r}
library(pheatmap)
pheatmap(temp_pca$rotation)
```

### 按照mfuzz的分类获取不同的
```{r fig.height=15, fig.width=9}

make_violin_of_rotation <- function(pcobj, mfuzz, n.pc=5) {
    temp = melt(pcobj$rotation[, 1:n.pc])
    
    temp = merge(temp, mfuzz, by.x = "Var1", by.y = "gene")
   
    temp$gene_module_id = factor(temp$gene_module_id) 
    ggplot(data = temp, aes(x = gene_module_id, y = value, fill = gene_module_id)) + 
        geom_violin() + 
        facet_grid(Var2~., scales = "free_y") +
        stat_summary(fun.y=median, geom="point", size=2) +
        geom_boxplot(width=0.1, fill = "white")
}


make_violin_of_rotation(temp_pca, mfuzz)
```


用所有module的基因
```{R fig.height=16, fig.width=16}
temp_pca <- prcomp(t(ap2@scale.data[unique(modules2$gene[modules2$Cells == "Alveolar_II_ADC"]), , drop = FALSE]), center = FALSE, scale. = FALSE)

p <- make_pca_plots(temp_pca, ap2, n.pcs = 16)
print(p)
```




Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
