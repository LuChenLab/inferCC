---
title: "big_radar_plots"
author: "Zhang Yiming"
date: "6/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

full.path <- function(path) {
    return(paste("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/scale_mean_for_radar_top_50", path, sep = "/"))
}
```


```{r lib}
library(dplyr)
library(fmsb)
library(reshape2)
library(openxlsx)
library(stringr)
library(wesanderson)
```


```{r func}
format_module <- function(modules, mfuzz=TRUE) {
    
    short_name = c(
        "Alveolar_II"="APII",
        "B_cells"="B",
        "Basal"="Basal",
        "CD4"="CD4",
        "Ciliated"="Cili",
        "Club"="Club",
        "Dendritic"="Dend",
        "Endothelial"="Endp",
        "Erythroid_precursor"="Eryt",
        "Fibroblasts"="Fibr",
        "Goblet"="Goblet",
        "Granulocyte"="Granu",
        "Mast"="Mast",
        "Monocytes"="Mono",
        "NK"="NK",
        "T_cells"="T",
        "Treg"="Treg",
        "Neuroendocrine"="Neuro",
        "Exhaust_T"="Exha"
    )
    
    
    res  = NULL
    
    for(i in 1:nrow(modules)) {
        temp_cell = short_name[[str_replace(modules[i, 1], "_(SCC|ADC)", "")]]
        
        temp = data.frame(
            gene = str_split(modules[i, "Genes"], "\\|")[[1]], 
            module_id = paste(temp_cell, modules[i, "Stage"], sep = "."),
            Cells = modules[i, "Cell_name"]
        )
        
        if(mfuzz) {
            temp$module_id = paste(temp$module_id, modules[i, "Mfuzz_ID"], sep = ".")
        }
        
        res = rbind(res, temp)
    }
    
    return(res)
}

```

## Make radar plots of all modules

Different plots
- by disease
    - ADC
    - SCC
- by Stage
    - I
    - II
    - III
    - IV

```{r data}
modules = read.xlsx("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/tmod_mfuzz_overlap_AUC_0.5_merged.xlsx", sheet = 2)

gene_expr = read.csv(full.path("mean_scale_data.csv"))
```

### Radar plot of ADC
```{r eval=FALSE, fig.height=12, fig.width=12, include=FALSE}
adc_expr = gene_expr[str_detect(gene_expr$Cells, "ADC$"), ]
adc_modules = format_module(modules[str_detect(modules$Cell_name, "ADC$"), ])
adc_modules$ident = paste(adc_modules$Cells, adc_modules$gene)

for(i in sort(unique(adc_expr$Stage))) {
    print(i)
    
    # format expression
    temp_expr = adc_expr[adc_expr$Stage == i, , drop = F]
    temp_expr$ident = paste(temp_expr$Cells, temp_expr$gene)
    
    temp = merge(temp_expr, adc_modules, by = "ident")
    temp$m = temp$total / temp$n
    
    temp <- temp %>% group_by(module_id, Patient) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, Patient, value) %>% unique()
    
    temp = dcast(temp, Patient~module_id)
    rownames(temp) <- temp$Patient
    
    temp <- temp[, -1]
    
    max_ = max(temp[!is.na(temp)])
    min_ = min(temp[!is.na(temp)])
    
    expr <- rbind(
        rep(ceiling(max_), ncol(temp)),
        rep(floor(min_), ncol(temp)),
        temp
    )
    
    
    par(
        mfrow=c(1, 2), 
        bty='n', 
        oma = c(0.5,0.5,0,0) + 0.1,
        mar = c(1,0,0,1) + 0.1
    )

    legend_labels = rownames(expr)
    legend_labels = legend_labels[3: length(legend_labels)]
    colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")

    radarchart(expr, axistype=1, 
        #custom polygon
        pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
        #custom the grid
        cglcol="grey", cglty=1, axislabcol="grey", 
        caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
        #custom labels
        vlcex=0.8 
    )
    plot(0, col="white", cex=0, axes=F, ann=FALSE)

    legend(
        "left",
        legend = legend_labels, 
        bty = "n", pch=20 , 
        col=colors_border , 
        text.col = "grey", 
        cex=1.2, 
        pt.cex=3,
        ncol = 2
    )
        
    
    break()
}
```

```{r eval=FALSE, fig.height=12, fig.width=12, include=FALSE}
test = as.data.frame(expr[c(-1, -2), ])

test[is.na(test)] <- floor(min(test[!is.na(test)])) - 1

test$group = rownames(test)

test <- test[, c(ncol(test), 2:(ncol(test) - 1)) ]

max_ = max(test[, -1])
min_ = min(test[, -1])

ggradar(
    test, 
    centre.y = -5, 
    grid.max = 2.5, 
    label.centre.y = TRUE, 
    values.radar = sapply(seq(min_, max_, length.out=3), round),
    axis.label.size = 3,
    group.line.width = 1, 
    group.point.size = 3
    )
```

### NC数据做图
```{r}
nc_expr_adc = read.csv("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/SYSU/ADC.csv", row.names = 1)
nc_expr_scc = read.csv("/mnt/raid62/Lung_cancer_10x/05_tmod_stage/SYSU/SCC.csv", row.names = 1)
```


```{r}
# function to sort colnames of expr, M.I.1 and so on.
sort_by_stage <- function(data) {
    data = sort(data)
    data = data[order(sapply(data, function(x){return(str_split(x, "\\.")[[1]][2])}))]
    return(data)
}
```


```{r fig.height=12, fig.width=12}
adc_modules = format_module(modules[str_detect(modules$Cell_name, "ADC$"), ], mfuzz = F)
adc_modules$ident = paste(adc_modules$Cells, adc_modules$gene)

for(i in c("I", "II", "III", "IV")) {
    print(i)
    
    temp_expr <- nc_expr_adc[, str_detect(colnames(nc_expr_adc), paste("_", i, "_", sep = "")), drop=FALSE]
    temp_expr <- log2(temp_expr + 1)
    
    print(colnames(temp_expr))
    
    temp_expr <- melt(as.matrix(temp_expr))
    colnames(temp_expr) <- c("gene", "Patient", "m")

    # format expression
    temp = merge(temp_expr, adc_modules, by = "gene")

    temp <- temp %>% group_by(module_id, Patient) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, Patient, value) %>% unique()
    
    temp = dcast(temp, Patient~module_id)
    rownames(temp) <- temp$Patient
    
    temp <- temp[, -1]
    
    max_ = max(temp[!is.na(temp)])
    min_ = min(temp[!is.na(temp)])
    
    expr <- rbind(
        rep(ceiling(max_), ncol(temp)),
        rep(floor(min_), ncol(temp)),
        temp
    )
    expr <- expr[, sort_by_stage(colnames(expr))]
    # par(
    #     mfrow=c(1, 2), 
    #     bty='n', 
    #     oma = c(0.5,0.5,0,0) + 0.1,
    #     mar = c(1,0,0,1) + 0.1
    # )

    legend_labels = rownames(expr)
    legend_labels = legend_labels[3: length(legend_labels)]
    colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")

    radarchart(expr, axistype=1, 
        #custom polygon
        pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
        #custom the grid
        cglcol="grey", cglty=1, axislabcol="grey", 
        caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
        #custom labels
        vlcex=0.8 
    )
    # plot(0, col="white", cex=0, axes=F, ann=FALSE)
    # 
    # legend(
    #     "left",
    #     legend = legend_labels, 
    #     bty = "n", pch=20 , 
    #     col=colors_border , 
    #     text.col = "grey", 
    #     cex=1.2, 
    #     pt.cex=3,
    #     ncol = 2
    # )
        
    
    # break()

}


```

```{r fig.height=12, fig.width=12}

# scc_expr = gene_expr[str_detect(gene_expr$Cells, "SCC$"), ]
scc_modules = format_module(modules[str_detect(modules$Cell_name, "SCC$"), ], mfuzz=T)
scc_modules$ident = paste(scc_modules$Cells, scc_modules$gene)

for(i in c("I", "II", "III", "IV")) {
    print(i)
    
    # get expression value of specific stage
    temp_expr <- nc_expr_scc[, str_detect(colnames(nc_expr_scc), paste("_", i, "_", sep = "")), drop=FALSE]
    
    print(colnames(temp_expr))
    
    # log2 transform
    temp_expr <- log2(temp_expr + 1)
    
    # format expression value
    temp_expr <- melt(as.matrix(temp_expr))
    colnames(temp_expr) <- c("gene", "Patient", "m")

    # merge with modules
    temp = merge(temp_expr, scc_modules, by = "gene")
    
    # calculate mean value by specific module and patient
    temp <- temp %>% group_by(module_id, Patient) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, Patient, value) %>% unique()
    
    # format data into matrix
    temp = dcast(temp, Patient~module_id)
    rownames(temp) <- temp$Patient
    
    temp <- temp[, -1]
    
    max_ = max(temp[!is.na(temp)])
    min_ = min(temp[!is.na(temp)])
    
    # add min, max and sort matrix by stage
    expr <- rbind(
        rep(ceiling(max_), ncol(temp)),
        rep(floor(min_), ncol(temp)),
        temp
    )
    expr = expr[, sort_by_stage(colnames(expr))]
    
    # par(
    #     mfrow=c(1, 2), 
    #     bty='n', 
    #     oma = c(0.5,0.5,0,0) + 0.1,
    #     mar = c(1,0,0,1) + 0.1
    # )

    legend_labels = rownames(expr)
    legend_labels = legend_labels[3: length(legend_labels)]
    colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")

    radarchart(expr, axistype=1, 
        #custom polygon
        pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
        #custom the grid
        cglcol="grey", cglty=1, axislabcol="grey", 
        caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
        #custom labels
        vlcex=0.8 
    )
    # plot(0, col="white", cex=0, axes=F, ann=FALSE)
    # 
    # legend(
    #     "left",
    #     legend = legend_labels, 
    #     bty = "n", pch=20 , 
    #     col=colors_border , 
    #     text.col = "grey", 
    #     cex=1.2, 
    #     pt.cex=3,
    #     ncol = 2
    # )
        
    # break()
}

```


#### 尝试将不同时期的数据作为不同的线放在图上

ADC
```{R fig.height=12, fig.width=24}

expr = NULL
for(i in c("I", "II", "III", "IV")) {
    print(i)
    
    # get expression value of specific stage
    temp_expr <- nc_expr_adc[, str_detect(colnames(nc_expr_adc), paste("_", i, "_", sep = "")), drop=FALSE]
    
    print(colnames(temp_expr))
    
    # log2 transform
    temp_expr <- log2(temp_expr + 1)
    
    # format expression value
    temp_expr <- melt(as.matrix(temp_expr))
    colnames(temp_expr) <- c("gene", "Patient", "m")

    # merge with modules
    temp = merge(temp_expr, adc_modules, by = "gene")
    
    # calculate mean value by specific module and patient
    temp <- temp %>% group_by(module_id) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, value) %>% unique()
    temp$Stage = i
    
    # format data into matrix
    temp = dcast(temp, Stage~module_id)
    expr = rbind(expr, temp)
}

rownames(expr) <- expr$Stage
expr <- expr[, -1]

max_ = max(expr[!is.na(expr)])
min_ = min(expr[!is.na(expr)])
    
# add min, max and sort matrix by stage
expr <- rbind(
    rep(ceiling(max_), ncol(expr)),
    rep(floor(min_), ncol(expr)),
    expr
)
expr = expr[, sort_by_stage(colnames(expr))]

par(
    mfrow=c(1, 2),
    bty='n',
    oma = c(0.5,0.5,0,0) + 0.1,
    mar = c(1,0,0,1) + 0.1
)

legend_labels = rownames(expr)
legend_labels = legend_labels[3: length(legend_labels)]
colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")

radarchart(expr, axistype=1, 
    #custom polygon
    pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
    #custom the grid
    cglcol="grey", cglty=1, axislabcol="grey", 
    caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
    #custom labels
    vlcex=0.8 
)
plot(0, col="white", cex=0, axes=F, ann=FALSE)

legend(
    "left",
    legend = legend_labels,
    bty = "n", pch=20 ,
    col=colors_border ,
    text.col = "grey",
    cex=1.2,
    pt.cex=3,
    ncol = 2
)
    
# break()
```




```{R fig.height=12, fig.width=24}

expr = NULL
for(i in c("I", "II", "III", "IV")) {
    print(i)
    
    # get expression value of specific stage
    temp_expr <- nc_expr_scc[, str_detect(colnames(nc_expr_scc), paste("_", i, "_", sep = "")), drop=FALSE]
    
    print(colnames(temp_expr))
    
    # log2 transform
    temp_expr <- log2(temp_expr + 1)
    
    # format expression value
    temp_expr <- melt(as.matrix(temp_expr))
    colnames(temp_expr) <- c("gene", "Patient", "m")

    # merge with modules
    temp = merge(temp_expr, scc_modules, by = "gene")
    
    # calculate mean value by specific module and patient
    temp <- temp %>% group_by(module_id) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, value) %>% unique()
    temp$Stage = i
    
    # format data into matrix
    temp = dcast(temp, Stage~module_id)
    expr = rbind(expr, temp)
}

rownames(expr) <- expr$Stage
expr <- expr[, -1]

max_ = max(expr[!is.na(expr)])
min_ = min(expr[!is.na(expr)])
    
# add min, max and sort matrix by stage
expr <- rbind(
    rep(ceiling(max_), ncol(expr)),
    rep(floor(min_), ncol(expr)),
    expr
)
expr = expr[, sort_by_stage(colnames(expr))]

par(
    mfrow=c(1, 2),
    bty='n',
    oma = c(0.5,0.5,0,0) + 0.1,
    mar = c(1,0,0,1) + 0.1
)

legend_labels = rownames(expr)
legend_labels = legend_labels[3: length(legend_labels)]
colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")

radarchart(expr, axistype=1, 
    #custom polygon
    pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
    #custom the grid
    cglcol="grey", cglty=1, axislabcol="grey", 
    caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
    #custom labels
    vlcex=0.8 
)
plot(0, col="white", cex=0, axes=F, ann=FALSE)

legend(
    "left",
    legend = legend_labels,
    bty = "n", pch=20 ,
    col=colors_border ,
    text.col = "grey",
    cex=1.2,
    pt.cex=3,
    ncol = 2
)
    
# break()
```


--- 

## Test the different expression of NC data


```{r pressure, echo=FALSE}
library(edgeR)
```

ADC
edgeR 做差异表达
```{r eval=FALSE, include=FALSE}
make_edger <- function(expr) {
    stages <- sapply(colnames(expr), function(x) {return(str_split(x, "_")[[1]][4])})
    
    res = NULL
    for(i in unique(stages)) {
        print(i)
        
        group = stages == i
        
        y <- DGEList(counts=expr, group=group)
        y <- calcNormFactors(y)
        design <- model.matrix(~group)
        y <- estimateDisp(y,design)
        
        fit <- glmQLFit(y, design)
        qlf <- glmQLFTest(fit, coef=2)
        
        temp = exactTest(y)$table
        temp$ident = i
        res = rbind(res, temp)
        
    }
    return(res)
}


et_adc <- make_edger(nc_expr_adc)
et_adc_de <- et_adc[et_adc$PValue < 0.05 & abs(et_adc$logFC) > 1, ]

print(dim(de_adc))
```

```{r eval=FALSE, include=FALSE}
et_scc <- make_edger(nc_expr_scc)
et_scc_de <- et_scc[et_scc$PValue < 0.05 & abs(et_scc$logFC) > 1, ]

print(dim(et_scc_de))
```

```{R eval=FALSE, include=FALSE}
wb = createWorkbook()
addWorksheet(wb, "ADC_All")
writeData(wb, 1, et_adc, rowNames = T)

addWorksheet(wb, "ADC_DE")
writeData(wb, 2, et_adc_de, rowNames = T)


addWorksheet(wb, "SCC_All")
writeData(wb, 3, et_scc, rowNames = T)

addWorksheet(wb, "SCC_DE")
writeData(wb, 4, et_scc_de, rowNames = T)

saveWorkbook(wb, file = full.path("NC_DEG.xlsx"), overwrite = T)
```


### MAKE vocano plots
```{R fig.height=6, fig.width=8}
et_adc <- read.xlsx(full.path("NC_DEG.xlsx"), sheet = 1, rowNames = T)

et_adc$group <- apply(et_adc, 1, function(x) {
    # print(x)
    
    if(as.numeric(x["logFC"]) > 1 && as.numeric(x["PValue"]) < 0.05) {
        return("Up")
    } else if (as.numeric(x["logFC"]) < -1 && as.numeric(x["PValue"]) < 0.05) {
        return("Down")
    } else {
        return("Not")
    }
})

et_adc$PValue <- -log10(et_adc$PValue)
et_adc$group <- as.character(et_adc$group)
et_adc$SingleCell <- 1
et_adc[as.character(unique(adc_modules$gene)), "SingleCell"] <- 2

ggplot(data=et_adc, aes(x=logFC, y=PValue, color=group, size = SingleCell)) + geom_point()
```

```{R fig.height=6, fig.width=8}
et_scc <- read.xlsx(full.path("NC_DEG.xlsx"), sheet = 3, rowNames = T)

et_scc$group <- apply(et_scc, 1, function(x) {
    # print(x)
    
    if(as.numeric(x["logFC"]) > 1 && as.numeric(x["PValue"]) < 0.05) {
        return("Up")
    } else if (as.numeric(x["logFC"]) < -1 && as.numeric(x["PValue"]) < 0.05) {
        return("Down")
    } else {
        return("Not")
    }
})

et_scc$PValue <- -log10(et_scc$PValue)
et_scc$SingleCell <- 1
et_scc[as.character(unique(scc_modules$gene)), "SingleCell"] <- 2

ggplot(data=et_scc, aes(x=logFC, y=PValue, color=group, size=SingleCell)) + geom_point()
```

```{r}
library(UpSetR)
```

##### ADC upsetR
```{R fig.height=6, fig.width=12}

adc_gene_list = list()
for(i in as.character(unique(et_adc$group))) {
    if (is.na(i)) {
        next
    }
    
    adc_gene_list[[i]] = rownames(et_adc[et_adc$group == i, ])
}
adc_gene_list[["SingleCell"]] <- unique(adc_modules$gene)

upset(fromList(adc_gene_list))
```


```{r fig.height=6, fig.width=12}
scc_gene_list = list()
for(i in as.character(unique(et_scc$group))) {
    if (is.na(i)) {
        next
    }
    
    scc_gene_list[[i]] = rownames(et_scc[et_scc$group == i, ])
}
scc_gene_list[["SingleCell"]] <- unique(scc_modules$gene)

upset(fromList(scc_gene_list))
```

---
### edgeR等需要counts做差异表达，现在换limma测试下

基本失败，在ADC中limma找不到差异表达
```{r}
make_limma <- function(expr) {
    stages <- sapply(colnames(expr), function(x) {return(str_split(x, "_")[[1]][4])})
    
    res = NULL
    for(i in unique(stages)) {
        print(i)
        
        group = data.frame(
            # Intercept=1:length(stages),
            stage=stages == i
        )
        
        group$stage[group$stage] = 1
        group$stage[group$stage == FALSE] = 0
        
        print(dim(group))
        print(dim(expr))
        
        E <- as.matrix(expr)
        fit <- eBayes(lmFit(E, group))
        tt <- topTable(fit, coef=1, number=Inf)
        tt$ident = i
        res = rbind(res, temp)
        
    }
    return(res)
}

adc_limma <- make_limma(nc_expr_adc)
```


--- 
### 做EBSeq试下

```{R}
library(EBSeq)
```

ADC
```{r}
Sizes=MedianNorm(nc_expr_adc)
EB_adc=EBMultiTest(
    Data=as.matrix(nc_expr_adc), 
    Conditions=as.factor(sapply(colnames(nc_expr_adc), function(x) {return(str_split(x, "_")[[1]][4])})),
    sizeFactors=Sizes,
    maxround=5
)

EBDEADC=GetMultiPP(EB_adc)


saveRDS(EB_adc, "/mnt/raid62/Lung_cancer_10x/05_tmod_stage/SYSU/ADC_EBSeq.rds")
```

SCC
```{R}
Sizes=MedianNorm(nc_expr_scc)
Conditions = as.factor(sapply(colnames(nc_expr_scc), function(x) {return(str_split(x, "_")[[1]][4])}))
PosParti=GetPatterns(Conditions)

PosParti=PosParti[c("Pattern2", "Pattern3", "Pattern5", "Pattern8", "Pattern15"), ]

EB_scc=EBMultiTest(
    Data=as.matrix(nc_expr_scc), 
    Conditions=Conditions,
    AllParti = PosParti,
    sizeFactors=Sizes,
    maxround=5
)

EBDESCC=GetMultiPP(EB_scc, FDR=0.05)
```


---

```{R}
stage_and_pattern = c(
    "I"="Pattern8",
    "II"="Pattern5",
    "III"="Pattern3",
    "IV"="Pattern2"
)



# get genes based on required pattern
extract_genes_by_pattern <- function(ebobj, stage, p.val = 0.05, logfc = 0) {
    
    pattern = stage_and_pattern[[stage]]
    
    logfc_mat = GetMultiFC(ebobj)$Log2FCMat
    
    times = rep(TRUE, nrow(logfc_mat))
    for(i in colnames(logfc_mat)) {
        temp = str_split(i, "Over")[[1]]
        
        if(temp[1] == i) {
            times = times & logfc_mat[, i] > logfc
        } else if (temp[2] == i) {
            times = times & logfc_mat[, i] * -1 > logfc
        }
    }

    # temp = rownames(ebobj$PP)[ebobj$PP[, pattern] < p.val]
    
    # print(length(temp))
    # 
    # temp = intersect(temp, rownames(logfc_mat[times, ]))
    
    return(rownames(logfc_mat[times, ]))
    
    # return (names(ebobj$MAP[ebobj$MAP == pattern]))
}
```

同时期不同细胞的gene module与ebseq同时期高表达的基因overlap
```{r}
library(UpSetR)
# make upset plot, to check to overlap of ebseq and all single cell genes from different cells at same stage
upset_between_ebseq_single_cell <- function(ebobj, modules) {
    modules$Stage = sapply(modules$module_id, function(x) {return(str_split(x, "\\.")[[1]][2])})
    
    data_list = list()
    
    for(i in unique(modules$Stage)) {
        gene_models = unique(modules$gene[modules$Stage == i])
        module_id = paste("module", i, sep = "_")
        data_list[[module_id]] = length(gene_models)
        
        gene_ebseq = unique(extract_genes_by_pattern(ebobj, stage=i))
        ebseq_id = paste("EBSeq", i, sep = "_")
        data_list[[ebseq_id]] = length(gene_ebseq)
        
        data_list[[paste(module_id, ebseq_id, sep = "&")]] = length(intersect(gene_models, gene_ebseq))
    }
    print(names(data_list))
    upset(fromExpression(data_list), nsets = length(data_list))
}


upset_between_ebseq_single_cell(EB_adc, adc_modules)
```

```{r}
# get overlap genes from ebseq and module
get_overlap_genes <- function(ebobj, modules) {
    modules$Stage = sapply(modules$module_id, function(x) {return(str_split(x, "\\.")[[1]][2])})
    
    new_module = NULL
    
    for(i in unique(modules$Stage)) {
        genes = unique(extract_genes_by_pattern(ebobj, i))
        
        new_module <- rbind(new_module, modules[modules$Stage == i & modules$gene %in% genes, ])
    }
    
    return(new_module)
}


adc_modules_ebseq <- get_overlap_genes(EB_adc, adc_modules)
```

```{r}

make_big_radar <- function(expr_mat, modules) {
    expr = NULL
    for(i in c("I", "II", "III", "IV")) {
        print(i)
        
        # get expression value of specific stage
        temp_expr <- expr_mat[, str_detect(colnames(expr_mat), paste("_", i, "_", sep = "")), drop=FALSE]
        
        print(colnames(temp_expr))
        
        # log2 transform
        temp_expr <- log2(temp_expr + 1)
        
        # format expression value
        temp_expr <- melt(as.matrix(temp_expr))
        colnames(temp_expr) <- c("gene", "Patient", "m")
        
        # merge with modules
        temp = merge(temp_expr, modules, by = "gene")
        
        # calculate mean value by specific module and patient
        temp <- temp %>% group_by(module_id) %>% mutate(value = mean(m)) %>% dplyr::select(module_id, value) %>% unique()
        temp$Stage = i
        
        # format data into matrix
        temp = dcast(temp, Stage~module_id)
        expr = rbind(expr, temp)
    }
    
    rownames(expr) <- expr$Stage
    expr <- expr[, -1]
    
    max_ = max(expr[!is.na(expr)])
    min_ = min(expr[!is.na(expr)])
    
    # add min, max and sort matrix by stage
    expr <- rbind(
        rep(ceiling(max_), ncol(expr)),
        rep(floor(min_), ncol(expr)),
        expr
    )
    expr = expr[, sort_by_stage(colnames(expr))]
    
    par(
        mfrow=c(1, 2),
        bty='n',
        oma = c(0.5,0.5,0,0) + 0.1,
        mar = c(1,0,0,1) + 0.1
    )
    
    legend_labels = rownames(expr)
    legend_labels = legend_labels[3: length(legend_labels)]
    colors_border = wes_palette("Zissou1", length(legend_labels), type = "continuous")
    
    radarchart(expr, axistype=1, 
               #custom polygon
               pcol=colors_border, # pfcol=colors_in, plwd=4 , plty=1, 
               #custom the grid
               cglcol="grey", cglty=1, axislabcol="grey", 
               caxislabels=seq(expr[2, 1], expr[1, 1], (expr[1, 1] - expr[2, 1]) / 5), cglwd=0.8,
               #custom labels
               vlcex=0.8 
    )
    plot(0, col="white", cex=0, axes=F, ann=FALSE)
    
    legend(
        "left",
        legend = legend_labels,
        bty = "n", pch=20 ,
        col=colors_border ,
        text.col = "grey",
        cex=1.2,
        pt.cex=3,
        ncol = 2
    )
}
```


```{r fig.height=8, fig.width=12}
make_big_radar(expr_mat = nc_expr_adc, modules = adc_modules_ebseq)
```


```{r fig.height=10, fig.width=12}
new_adc_modules_ebseq = adc_modules
new_adc_modules_ebseq$Stage = sapply(new_adc_modules_ebseq$module_id, function(x) {return(str_split(x, "\\.")[[1]][2])})

new_adc_modules_ebseq$module_id = paste("M", new_adc_modules_ebseq$Stage, sep = ".")

make_big_radar(expr_mat = nc_expr_adc, modules = new_adc_modules_ebseq[table(new_adc_modules_ebseq$gene) > 0, ])
```

检查下同时期不同细胞的基因的overlap

```{r fig.height=8, fig.width=8}

make_upset_between_different_cells_same_stage <- function(modules) {
    modules$Stage = sapply(modules$module_id, function(x) {return(str_split(x, "\\.")[[1]][2])})
    
    for(i in unique(modules$Stage)) {
        data_list = list()
        
        temp = modules[modules$Stage == i, ]
        
        for (j in unique(temp$module_id)) {
            data_list[[j]] = temp[temp$module_id == j, "gene"]
        }
        
        upset(fromList(data_list), nsets = length(data_list))
    }
}

make_upset_between_different_cells_same_stage(adc_modules)

```



---
### Check the overlap between edgeR DEGs and modules
```{r}

get_overlap_between_edger_modules <- function(edger, modules) {
    module_ids = unique(modules$module_id)
    res = matrix(NA, ncol = 4, nrow = length(module_ids))
    
    for (i in 1:length(module_ids)) {
        res[i, 1] = as.character(module_ids[i])
        module_genes = modules[modules$module_id == module_ids[i], "gene"]
        
        overlap = intersect(module_genes, rownames(edger[edger$group == "Up",]))
        res[i, 2] = length(overlap)
        
        overlap = intersect(module_genes, rownames(edger[edger$group == "Down",]))
        res[i, 3] = length(overlap)
        
        overlap = intersect(module_genes, rownames(edger[edger$group == "Not",]))
        res[i, 4] = length(overlap)
    }
    
    res = as.data.frame(res)
    colnames(res) <- c("module_id", "Up", "Down", "Not")
    return(res)
}

adc_overlap <- get_overlap_between_edger_modules(et_adc, adc_modules)
scc_overlap <- get_overlap_between_edger_modules(et_scc, scc_modules)
```



Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
